import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:flutter_chat_ui/flutter_chat_ui.dart';
import 'package:flutter_chat_types/flutter_chat_types.dart' as types;
import 'package:flutter/foundation.dart';
import 'package:uuid/uuid.dart';
import 'package:image_picker/image_picker.dart';
import 'package:flutter_tts/flutter_tts.dart';
import 'package:speech_to_text/speech_to_text.dart' as stt;

import '../providers/chat_provider.dart';
import '../providers/girlfriend_provider.dart';
import '../providers/auth_provider.dart';
import '../widgets/chat_app_bar.dart';
import '../widgets/video_generation_progress.dart';
import '../widgets/video_message_widget.dart';
import '../services/video_generation_service.dart' show VideoGenerationService, VideoGenerationStatus;

class ChatScreen extends StatefulWidget {
  const ChatScreen({Key? key}) : super(key: key);

  @override
  State<ChatScreen> createState() => _ChatScreenState();
}

class _ChatScreenState extends State<ChatScreen> {
  final _uuid = const Uuid();
  final FlutterTts _flutterTts = FlutterTts();
  final stt.SpeechToText _speech = stt.SpeechToText();
  bool _isSpeaking = false;
  bool _isTyping = false;
  bool _isListening = false;
  String _recognizedText = '';
  final TextEditingController _textController = TextEditingController();
  bool _isGeneratingAIHelp = false;
  bool _isGeneratingVideo = false;
  VideoGenerationStatus _videoStatus = VideoGenerationStatus.idle;
  double _videoProgress = 0.0;
  String _videoMessage = '';

  @override
  void initState() {
    super.initState();
    _initializeTts();
    _initializeSpeech();
    _loadMessages();
  }

  Future<void> _initializeTts() async {
    await _flutterTts.setLanguage('zh-CN');
    await _flutterTts.setSpeechRate(0.5);
    await _flutterTts.setVolume(1.0);
    await _flutterTts.setPitch(1.0);
    
    _flutterTts.setCompletionHandler(() {
      setState(() {
        _isSpeaking = false;
      });
    });
  }

  Future<void> _initializeSpeech() async {
    await _speech.initialize();
  }

  Future<void> _loadMessages() async {
    final chatProvider = Provider.of<ChatProvider>(context, listen: false);
    final girlfriendProvider = Provider.of<GirlfriendProvider>(context, listen: false);
    
    if (girlfriendProvider.currentGirlfriend == null) {
      // If no girlfriend is selected, redirect to home
      // Navigator.of(context).pushReplacementNamed('/home');
      return;
    }
    
    try {
      await chatProvider.loadMessages(girlfriendProvider.currentGirlfriend!.id);
    } catch (error) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Âä†ËΩΩÊ∂àÊÅØÂ§±Ë¥•: ${error.toString()}'))
        );
      }
    }
  }

  void _handleSendPressed(types.PartialText message) async {
    final chatProvider = Provider.of<ChatProvider>(context, listen: false);
    final girlfriendProvider = Provider.of<GirlfriendProvider>(context, listen: false);
    
    final textMessage = types.TextMessage(
      author: chatProvider.user,
      createdAt: DateTime.now().millisecondsSinceEpoch,
      id: _uuid.v4(),
      text: message.text,
    );
    
    chatProvider.addMessage(textMessage);
    
    // Update last message in girlfriend provider for user message
    await girlfriendProvider.updateLastMessage(
      girlfriendProvider.currentGirlfriend!.id,
      message.text,
    );
    
    // Ê£ÄÊü•ÊòØÂê¶‰∏∫ËßÜÈ¢ëÁîüÊàêËØ∑Ê±Ç
    if (chatProvider.isVideoGenerationRequest(message.text)) {
      _handleVideoGenerationRequest(message.text, chatProvider, girlfriendProvider);
      return;
    }
    
    // Show typing indicator
    setState(() {
      _isTyping = true;
    });
    
    try {
      // Get AI response with secondary personality support
      final responseData = await chatProvider.getAIResponse(
        message.text,
        girlfriendProvider.currentGirlfriend!.id,
        girlfriendProvider.currentGirlfriend!.personality,
        girlfriendData: girlfriendProvider.currentGirlfriend!.toJson(),
      );
      
      final String response = responseData['response'];
      final int intimacyChange = responseData['intimacyChange'];
      final List<String> usedKnowledge = responseData['usedKnowledge'] ?? [];
      final double confidence = responseData['confidence'] ?? 0.5;
      
      // Êõ¥Êñ∞Â•ΩÊÑüÂ∫¶
      if (intimacyChange != 0) {
        await girlfriendProvider.updateIntimacy(
          girlfriendProvider.currentGirlfriend!.id,
          intimacyChange
        );
        
        // ÊòæÁ§∫Â•ΩÊÑüÂ∫¶ÂèòÂåñÊèêÁ§∫
        if (mounted && intimacyChange > 0) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Â•ΩÊÑüÂ∫¶ +$intimacyChange'),
              duration: const Duration(seconds: 1),
              backgroundColor: Colors.pink[100],
            )
          );
        }
      }
      
      // ÊòæÁ§∫RAGÂäüËÉΩ‰ΩøÁî®ÊèêÁ§∫
      if (mounted && usedKnowledge.isNotEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('üí° ‰ΩøÁî®‰∫ÜÁü•ËØÜÂ∫ì: ${usedKnowledge.join(', ')} (ÁΩÆ‰ø°Â∫¶: ${(confidence * 100).toInt()}%)'),
            duration: const Duration(seconds: 2),
            backgroundColor: Colors.blue[100],
            behavior: SnackBarBehavior.floating,
          )
        );
      }
      
      final responseMessage = types.TextMessage(
        author: types.User(
          id: girlfriendProvider.currentGirlfriend!.id,
          firstName: girlfriendProvider.currentGirlfriend!.name,
          imageUrl: girlfriendProvider.currentGirlfriend!.avatarUrl,
        ),
        createdAt: DateTime.now().millisecondsSinceEpoch,
        id: _uuid.v4(),
        text: response,
      );
      
      await chatProvider.addMessage(responseMessage);
      
      // Update last message in girlfriend provider
      await girlfriendProvider.updateLastMessage(
        girlfriendProvider.currentGirlfriend!.id,
        response,
      );
      
      // Speak the response if TTS is enabled
      if (chatProvider.isTtsEnabled) {
        _speakText(response);
      }
    } catch (error) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Ëé∑ÂèñÂõûÂ§çÂ§±Ë¥•: ${error.toString()}'))
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isTyping = false;
        });
      }
    }
  }

  void _handleAttachmentPressed() {
    showModalBottomSheet<void>(
      context: context,
      builder: (BuildContext context) {
        return SafeArea(
          child: SizedBox(
            height: 144,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: <Widget>[
                TextButton(
                  onPressed: () {
                    Navigator.pop(context);
                    _handleImageSelection();
                  },
                  child: const Align(
                    alignment: Alignment.centerLeft,
                    child: Text('ÁÖßÁâá'),
                  ),
                ),
                TextButton(
                  onPressed: () {
                    Navigator.pop(context);
                    _handleCameraSelection();
                  },
                  child: const Align(
                    alignment: Alignment.centerLeft,
                    child: Text('Áõ∏Êú∫'),
                  ),
                ),
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Align(
                    alignment: Alignment.centerLeft,
                    child: Text('ÂèñÊ∂à'),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  void _handleImageSelection() async {
    final result = await ImagePicker().pickImage(
      source: ImageSource.gallery,
      imageQuality: 70,
      maxWidth: 1440,
    );

    if (result != null) {
      _setAttachmentMessage(result);
    }
  }

  void _handleCameraSelection() async {
    final picker = ImagePicker();
    final result = await picker.pickImage(
      source: ImageSource.camera,
      imageQuality: 70,
      maxWidth: 1440,
    );

    if (result != null) {
      _setAttachmentMessage(result);
    }
  }

  void _setAttachmentMessage(XFile file) async {
    final chatProvider = Provider.of<ChatProvider>(context, listen: false);
    final girlfriendProvider = Provider.of<GirlfriendProvider>(context, listen: false);
    
    final bytes = await file.readAsBytes();
    final image = await decodeImageFromList(bytes);

    final message = types.ImageMessage(
      author: chatProvider.user,
      createdAt: DateTime.now().millisecondsSinceEpoch,
      height: image.height.toDouble(),
      id: _uuid.v4(),
      name: file.name,
      size: bytes.length,
      uri: file.path,
      width: image.width.toDouble(),
    );

    await chatProvider.addMessage(message);
    
    // Show typing indicator
    setState(() {
      _isTyping = true;
    });
    
    try {
      // Get AI response to image
      final responseData = await chatProvider.getAIResponseToImage(
        file.path,
        girlfriendProvider.currentGirlfriend!.id,
        girlfriendProvider.currentGirlfriend!.personality,
      );
      
      final String response = responseData['response'];
      final int intimacyChange = responseData['intimacyChange'];
      
      // Êõ¥Êñ∞Â•ΩÊÑüÂ∫¶
      if (intimacyChange != 0) {
        await girlfriendProvider.updateIntimacy(
          girlfriendProvider.currentGirlfriend!.id,
          intimacyChange
        );
        
        // ÊòæÁ§∫Â•ΩÊÑüÂ∫¶ÂèòÂåñÊèêÁ§∫
        if (mounted && intimacyChange > 0) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Â•ΩÊÑüÂ∫¶ +$intimacyChange'),
              duration: const Duration(seconds: 1),
              backgroundColor: Colors.pink[100],
            )
          );
        }
      }
      
      final responseMessage = types.TextMessage(
        author: types.User(
          id: girlfriendProvider.currentGirlfriend!.id,
          firstName: girlfriendProvider.currentGirlfriend!.name,
          imageUrl: girlfriendProvider.currentGirlfriend!.avatarUrl,
        ),
        createdAt: DateTime.now().millisecondsSinceEpoch,
        id: _uuid.v4(),
        text: response,
      );
      
      await chatProvider.addMessage(responseMessage);
      
      // Speak the response if TTS is enabled
      if (chatProvider.isTtsEnabled) {
        _speakText(response);
      }
    } catch (error) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Ëé∑ÂèñÂõûÂ§çÂ§±Ë¥•: ${error.toString()}'))
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isTyping = false;
        });
      }
    }
  }

  Future<void> _speakText(String text) async {
    if (_isSpeaking) {
      await _flutterTts.stop();
      setState(() {
        _isSpeaking = false;
      });
      return;
    }
    
    setState(() {
      _isSpeaking = true;
    });
    
    await _flutterTts.speak(text);
  }

  Future<void> _startListening() async {
    if (!_isListening) {
      bool available = await _speech.initialize();
      if (available) {
        setState(() {
          _isListening = true;
          _recognizedText = '';
        });
        
        _speech.listen(
          onResult: (result) {
            setState(() {
              _recognizedText = result.recognizedWords;
            });
          },
          localeId: 'zh_CN',
        );
      }
    }
  }

  Future<void> _stopListening() async {
    if (_isListening) {
      _speech.stop();
      setState(() {
        _isListening = false;
      });
      
      if (_recognizedText.isNotEmpty) {
        _handleSendPressed(types.PartialText(text: _recognizedText));
      }
    }
  }
  
  // Â§ÑÁêÜËßÜÈ¢ëÁîüÊàêËØ∑Ê±Ç
  void _handleVideoGenerationRequest(
    String prompt, 
    ChatProvider chatProvider, 
    GirlfriendProvider girlfriendProvider
  ) async {
    setState(() {
      _isGeneratingVideo = true;
      _videoStatus = VideoGenerationStatus.idle;
      _videoProgress = 0.0;
      _videoMessage = 'ÂáÜÂ§áÁîüÊàêËßÜÈ¢ë...';
    });
    
    try {
      final responseData = await chatProvider.generateVideoResponse(
        prompt,
        girlfriendProvider.currentGirlfriend!.id,
        girlfriendProvider.currentGirlfriend!.personality,
        (status, progress, message) {
          if (mounted) {
            setState(() {
              _videoStatus = status;
              _videoProgress = progress;
              _videoMessage = message;
            });
          }
        },
      );
      
      if (responseData.containsKey('error')) {
        // ÊòæÁ§∫ÈîôËØØÊ∂àÊÅØ
        final errorMessage = types.TextMessage(
          author: types.User(
            id: girlfriendProvider.currentGirlfriend!.id,
            firstName: girlfriendProvider.currentGirlfriend!.name,
            imageUrl: girlfriendProvider.currentGirlfriend!.avatarUrl,
          ),
          createdAt: DateTime.now().millisecondsSinceEpoch,
          id: _uuid.v4(),
          text: 'Êä±Ê≠âÔºå${responseData['error']}ÔºåËØ∑Á®çÂêéÂÜçËØï„ÄÇ',
        );
        
        await chatProvider.addMessage(errorMessage);
      } else {
        // Ê∑ªÂä†ÊñáÂ≠óÂõûÂ§ç
        final textResponse = types.TextMessage(
          author: types.User(
            id: girlfriendProvider.currentGirlfriend!.id,
            firstName: girlfriendProvider.currentGirlfriend!.name,
            imageUrl: girlfriendProvider.currentGirlfriend!.avatarUrl,
          ),
          createdAt: DateTime.now().millisecondsSinceEpoch,
          id: _uuid.v4(),
          text: responseData['textResponse'],
        );
        
        await chatProvider.addMessage(textResponse);
        
        // Ê∑ªÂä†ËßÜÈ¢ëÊ∂àÊÅØÔºà‰ΩøÁî®Ëá™ÂÆö‰πâÊ∂àÊÅØÁ±ªÂûãÔºâ
        final videoMessage = types.CustomMessage(
          author: types.User(
            id: girlfriendProvider.currentGirlfriend!.id,
            firstName: girlfriendProvider.currentGirlfriend!.name,
            imageUrl: girlfriendProvider.currentGirlfriend!.avatarUrl,
          ),
          createdAt: DateTime.now().millisecondsSinceEpoch,
          id: _uuid.v4(),
          metadata: {
            'type': 'video',
            'videoPath': responseData['videoPath'],
            'prompt': prompt,
          },
        );
        
        await chatProvider.addMessage(videoMessage);
        
        // Êõ¥Êñ∞Â•ΩÊÑüÂ∫¶
        final intimacyChange = responseData['intimacyChange'] ?? 0;
        if (intimacyChange > 0) {
          await girlfriendProvider.updateIntimacy(
            girlfriendProvider.currentGirlfriend!.id,
            intimacyChange
          );
          
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Â•ΩÊÑüÂ∫¶ +$intimacyChange'),
                duration: const Duration(seconds: 2),
                backgroundColor: Colors.pink[100],
              )
            );
          }
        }
        
        // Êí≠ÊîæÊñáÂ≠óÂõûÂ§çÔºàÂ¶ÇÊûúÂêØÁî®TTSÔºâ
        if (chatProvider.isTtsEnabled) {
          _speakText(responseData['textResponse']);
        }
      }
    } catch (error) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('ËßÜÈ¢ëÁîüÊàêÂ§±Ë¥•: ${error.toString()}'))
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isGeneratingVideo = false;
          _videoStatus = VideoGenerationStatus.idle;
        });
      }
    }
  }
  
  // ÂèñÊ∂àËßÜÈ¢ëÁîüÊàê
   void _cancelVideoGeneration() {
     setState(() {
       _isGeneratingVideo = false;
       _videoStatus = VideoGenerationStatus.idle;
     });
     
     ScaffoldMessenger.of(context).showSnackBar(
       const SnackBar(content: Text('ËßÜÈ¢ëÁîüÊàêÂ∑≤ÂèñÊ∂à'))
     );
   }
   
   // Ëá™ÂÆö‰πâÊ∂àÊÅØÊûÑÂª∫Âô®
   Widget _customMessageBuilder(
     types.CustomMessage message, {
     required int messageWidth,
   }) {
     final metadata = message.metadata ?? {};
     
     if (metadata['type'] == 'video') {
       return Container(
         constraints: BoxConstraints(maxWidth: messageWidth.toDouble()),
         child: VideoMessageWidget(
           videoPath: metadata['videoPath'] ?? '',
           prompt: metadata['prompt'] ?? '',
           onPlay: () {
             // ÂèØ‰ª•Âú®ËøôÈáåÊ∑ªÂä†ËßÜÈ¢ëÊí≠ÊîæÁöÑÁªüËÆ°ÊàñÂÖ∂‰ªñÈÄªËæë
             debugPrint('ÂºÄÂßãÊí≠ÊîæËßÜÈ¢ë: ${metadata['videoPath']}');
           },
           onPause: () {
             // ÂèØ‰ª•Âú®ËøôÈáåÊ∑ªÂä†ËßÜÈ¢ëÊöÇÂÅúÁöÑÁªüËÆ°ÊàñÂÖ∂‰ªñÈÄªËæë
             debugPrint('ÊöÇÂÅúÊí≠ÊîæËßÜÈ¢ë: ${metadata['videoPath']}');
           },
         ),
       );
     }
     
     // Â¶ÇÊûú‰∏çÊòØËßÜÈ¢ëÊ∂àÊÅØÔºåËøîÂõûÈªòËÆ§ÁöÑÊñáÊú¨ÊòæÁ§∫
     return Container(
       constraints: BoxConstraints(maxWidth: messageWidth.toDouble()),
       padding: const EdgeInsets.all(12),
       decoration: BoxDecoration(
         color: Colors.grey[100],
         borderRadius: BorderRadius.circular(12),
       ),
       child: Text(
         'Êú™Áü•Ê∂àÊÅØÁ±ªÂûã: ${metadata['type'] ?? 'unknown'}',
         style: const TextStyle(color: Colors.grey),
       ),
     );
   }

  @override
  void dispose() {
    _flutterTts.stop();
    _speech.stop();
    _textController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final chatProvider = Provider.of<ChatProvider>(context);
    final girlfriendProvider = Provider.of<GirlfriendProvider>(context);
    
    if (girlfriendProvider.currentGirlfriend == null) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }
    
    return Scaffold(
      appBar: PreferredSize(
        preferredSize: const Size.fromHeight(60),
        child: ChatAppBar(
          girlfriend: girlfriendProvider.currentGirlfriend!,
          isSpeaking: _isSpeaking,
          onTtsToggle: () {
            if (_isSpeaking) {
              _flutterTts.stop();
              setState(() {
                _isSpeaking = false;
              });
            }
            chatProvider.toggleTts();
          },
          isTtsEnabled: chatProvider.isTtsEnabled,
        ),
      ),
      body: Column(
        children: [
          // ËßÜÈ¢ëÁîüÊàêËøõÂ∫¶ÊòæÁ§∫
          if (_isGeneratingVideo)
            VideoGenerationProgress(
              status: _videoStatus,
              progress: _videoProgress,
              message: _videoMessage,
              onCancel: _cancelVideoGeneration,
            ),
          // ËÅäÂ§©ÁïåÈù¢
          Expanded(
            child: Chat(
               messages: chatProvider.messages,
               onSendPressed: _handleSendPressed,
               user: chatProvider.user,
               customMessageBuilder: _customMessageBuilder,
              theme: DefaultChatTheme(
                primaryColor: Colors.pink.shade400,
                secondaryColor: Colors.grey.shade200,
                backgroundColor: Colors.white,
                inputBackgroundColor: Colors.grey.shade100,
                inputTextColor: Colors.black87,
                inputTextCursorColor: Colors.pink.shade400,
                sentMessageBodyTextStyle: const TextStyle(color: Colors.white),
                receivedMessageBodyTextStyle: const TextStyle(color: Colors.black87),
              ),
              showUserAvatars: true,
              showUserNames: true,
              // enablePreviewUrlsInMessage: true, // ÂèÇÊï∞ÂèØËÉΩ‰∏çÂ≠òÂú®ÔºåÂÖàÊ≥®ÈáäÊéâ
              onPreviewDataFetched: (types.TextMessage message, types.PreviewData previewData) {
                final index = chatProvider.messages.indexWhere((element) => element.id == message.id);
                if (index != -1) {
                  chatProvider.updateMessage(message.copyWith(previewData: previewData), index);
                }
              },
              typingIndicatorOptions: TypingIndicatorOptions(
                typingUsers: _isTyping ? [types.User(
                  id: girlfriendProvider.currentGirlfriend!.id,
                  firstName: girlfriendProvider.currentGirlfriend!.name,
                )] : [],
              ),
               customBottomWidget: _buildCustomInputWidget(),
               // customBottomWidgetBuilder ÂèÇÊï∞ÂèØËÉΩ‰∏çÂ≠òÂú®ÔºåÂÖàÊ≥®ÈáäÊéâ
               // customBottomWidgetBuilder: (_) => _isListening ? null : Padding(
               //   padding: const EdgeInsets.only(left: 16, right: 16, bottom: 16),
               //   child: Row(
               //     children: [
               //       VoiceInputButton(
               //         onPressed: _startListening,
               //       ),
               //       const SizedBox(width: 16),
               //       Expanded(
               //         child: Container(),
               //       ),
               //     ],
               //   ),
               // ),
               onAttachmentPressed: _handleAttachmentPressed,
             ),
           ),
         ],
       ),
    );
  }
  
  Widget _buildCustomInputWidget() {
    if (_isListening) {
      return Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        color: Colors.grey.shade100,
        child: Row(
          children: [
            Expanded(
              child: Text(
                _recognizedText.isEmpty ? 'Ê≠£Âú®ËÅÜÂê¨...' : _recognizedText,
                style: TextStyle(
                  color: _recognizedText.isEmpty ? Colors.grey : Colors.black87,
                ),
              ),
            ),
            IconButton(
              icon: const Icon(Icons.send),
              color: Colors.pink.shade400,
              onPressed: _stopListening,
            ),
            IconButton(
              icon: const Icon(Icons.close),
              color: Colors.grey,
              onPressed: () {
                _speech.stop();
                setState(() {
                  _isListening = false;
                  _recognizedText = '';
                });
              },
            ),
          ],
        ),
      );
    }
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.white,
        border: Border(top: BorderSide(color: Colors.grey.shade300)),
      ),
      child: Row(
        children: [
          // AIËæÖÂä©ÂØπËØùÊåâÈíÆ
          IconButton(
            icon: _isGeneratingAIHelp 
                ? SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      valueColor: AlwaysStoppedAnimation<Color>(Colors.blue.shade400),
                    ),
                  )
                : Icon(
                    Icons.psychology,
                    color: Colors.blue.shade400,
                  ),
            onPressed: _isGeneratingAIHelp ? null : _handleAIAssist,
            tooltip: 'AIËæÖÂä©ÂØπËØù',
          ),
          // ËæìÂÖ•Ê°Ü
          Expanded(
            child: Container(
              margin: const EdgeInsets.symmetric(horizontal: 8),
              decoration: BoxDecoration(
                color: Colors.grey.shade100,
                borderRadius: BorderRadius.circular(20),
              ),
              child: TextField(
                controller: _textController,
                decoration: const InputDecoration(
                  hintText: 'ËæìÂÖ•Ê∂àÊÅØ...',
                  border: InputBorder.none,
                  contentPadding: EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 10,
                  ),
                ),
                maxLines: null,
                textInputAction: TextInputAction.send,
                onSubmitted: (text) {
                  if (text.trim().isNotEmpty) {
                    _sendMessage(text.trim());
                  }
                },
              ),
            ),
          ),
          // ËØ≠Èü≥ËæìÂÖ•ÊåâÈíÆ
          IconButton(
            icon: Icon(
              Icons.mic,
              color: Colors.grey.shade600,
            ),
            onPressed: _startListening,
            tooltip: 'ËØ≠Èü≥ËæìÂÖ•',
          ),
          // ÂèëÈÄÅÊåâÈíÆ
          IconButton(
            icon: Icon(
              Icons.send,
              color: Colors.pink.shade400,
            ),
            onPressed: () {
              final text = _textController.text.trim();
              if (text.isNotEmpty) {
                _sendMessage(text);
              }
            },
            tooltip: 'ÂèëÈÄÅ',
          ),
        ],
      ),
    );
  }
  
  void _sendMessage(String text) {
    final message = types.PartialText(text: text);
    _handleSendPressed(message);
    _textController.clear();
  }
  
  Future<void> _handleAIAssist() async {
    if (!mounted) return;
    
    final chatProvider = Provider.of<ChatProvider>(context, listen: false);
    final girlfriendProvider = Provider.of<GirlfriendProvider>(context, listen: false);
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    
    // Ê£ÄÊü•ÈáëÂ∏Å‰ΩôÈ¢ù
    const aiAssistCost = 5; // AIËæÖÂä©ÂØπËØùÊ∂àËÄó5ÈáëÂ∏Å
    if (authProvider.coinBalance < aiAssistCost) {
       if (mounted) {
         scaffoldMessenger.showSnackBar(
           const SnackBar(
             content: Text('ÈáëÂ∏Å‰∏çË∂≥ÔºåÊó†Ê≥ï‰ΩøÁî®AIËæÖÂä©ÂØπËØùÂäüËÉΩ'),
             backgroundColor: Colors.orange,
           ),
         );
       }
       return;
     }
    
    setState(() {
      _isGeneratingAIHelp = true;
    });
    
    try {
      // Ëé∑ÂèñÊúÄËøëÁöÑËÅäÂ§©ËÆ∞ÂΩï‰Ωú‰∏∫‰∏ä‰∏ãÊñá
      final recentMessages = chatProvider.messages.take(5).toList();
      String context = '';
      for (final message in recentMessages.reversed) {
        if (message is types.TextMessage) {
          final isUser = message.author.id == chatProvider.user.id;
          context += '${isUser ? "Áî®Êà∑" : girlfriendProvider.currentGirlfriend?.name ?? "AI"}: ${message.text}\n';
        }
      }
      
      // ÁîüÊàêAIÂª∫ËÆÆÁöÑÂõûÂ§ç
      final responseData = await chatProvider.getAIResponse(
        'ËØ∑Ê†πÊçÆ‰ª•‰∏ãÂØπËØù‰∏ä‰∏ãÊñáÔºå‰∏∫Áî®Êà∑ÁîüÊàê‰∏Ä‰∏™ÂêàÈÄÇÁöÑÂõûÂ§çÂª∫ËÆÆÔºö\n$context\nËØ∑ÁîüÊàê‰∏Ä‰∏™Ëá™ÁÑ∂„ÄÅÊúâË∂£ÁöÑÂõûÂ§çÂª∫ËÆÆ„ÄÇ',
        girlfriendProvider.currentGirlfriend!.id,
        girlfriendProvider.currentGirlfriend!.personality,
      );
      
      final suggestion = responseData['response'] as String;
      
      // Êâ£Èô§ÈáëÂ∏Å
      await authProvider.deductCoins(aiAssistCost);
      
      if (mounted) {
         // Â∞ÜÂª∫ËÆÆÂ°´ÂÖ•ËæìÂÖ•Ê°Ü
         _textController.text = _cleanAISuggestion(suggestion);
         
         scaffoldMessenger.showSnackBar(
           SnackBar(
             content: Text('AIÂª∫ËÆÆÂ∑≤ÁîüÊàêÔºåÊ∂àËÄó $aiAssistCost ÈáëÂ∏Å'),
             backgroundColor: Colors.green,
             duration: const Duration(seconds: 2),
           ),
         );
       }
    } catch (error) {
       if (mounted) {
         scaffoldMessenger.showSnackBar(
           SnackBar(
             content: Text('AIËæÖÂä©ÁîüÊàêÂ§±Ë¥•: ${error.toString()}'),
             backgroundColor: Colors.red,
           ),
         );
       }
    } finally {
      if (mounted) {
        setState(() {
          _isGeneratingAIHelp = false;
        });
      }
    }
  }
  
  String _cleanAISuggestion(String suggestion) {
    // Ê∏ÖÁêÜAIÁîüÊàêÁöÑÂª∫ËÆÆÔºåÁßªÈô§‰∏çÂøÖË¶ÅÁöÑÂâçÁºÄÂíåÊ†ºÂºè
    String cleaned = suggestion;
    
    // ÁßªÈô§Â∏∏ËßÅÁöÑAIÂõûÂ§çÂâçÁºÄ
    final prefixes = [
      'Ê†πÊçÆÂØπËØù‰∏ä‰∏ãÊñáÔºåÊàëÂª∫ËÆÆ‰Ω†ÂèØ‰ª•ÂõûÂ§çÔºö',
      '‰Ω†ÂèØ‰ª•ËøôÊ†∑ÂõûÂ§çÔºö',
      'Âª∫ËÆÆÂõûÂ§çÔºö',
      'ÂõûÂ§çÂª∫ËÆÆÔºö',
      '‰Ω†ÂèØ‰ª•ËØ¥Ôºö',
      'Âª∫ËÆÆ‰Ω†ËØ¥Ôºö',
    ];
    
    for (final prefix in prefixes) {
      if (cleaned.startsWith(prefix)) {
        cleaned = cleaned.substring(prefix.length).trim();
        break;
      }
    }
    
    // ÁßªÈô§ÂºïÂè∑
    if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
      cleaned = cleaned.substring(1, cleaned.length - 1);
    }
    if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
      cleaned = cleaned.substring(1, cleaned.length - 1);
    }
    
    return cleaned.trim();
  }
}